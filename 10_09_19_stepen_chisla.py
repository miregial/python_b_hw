#!/usr/bin/env python
# coding: utf-8

# In[17]:


def r_power(a,n,m): #число в степени по модулю
    if n==0:
        return 1
    if n%2==0:
        print("четное", n)
        b = r_power(a,n//2,m)%m #без %m будет число в степени
        b = (b*b)%m
    else: 
        print("нечетное", n)
        b = r_power(a,n//2,m)%m
        b=(a*b*b)%m
    return b
r_power(2,100,100)


# In[18]:


print(f"2+2={2+2}" )


# In[ ]:


num - числитель
denum - знаменатель


# In[ ]:


СТР 256 ПЕРЕГРУЗКА ОПЕРАТОРА ДЛЯ ТОГО ЧТОБЫ РАБОТАЛИ МЕТОДЫ МАТЕМАТИЧЕСКИХ ДЕЙСТВИЙ
~х — двоичная инверсия: х .__in v e rt__();
♦ х & у — двоичное И: х .__and__(у);
♦ у s х — двоичное И (экземпляр класса справа): х .__rand__(у);
♦ х s= у — двоичное И и присваивание: х .__iand__(у);
♦ х | у — двоичное ИЛИ: х .__or__(у);
♦ у I х — двоичное ИЛИ (экземпляр класса справа): х .__гог__(у);
♦ х | = у — двоичное ИЛИ и присваивание: х .__io r__(у);
♦ х л у — двоичное исключающее ИЛИ: х .__хог__(у);
♦ у л х — двоичное исключающее ИЛИ (экземпляр класса справа): х .__гхог__(у);
♦ х л= у — двоичное исключающее ИЛИ и присваивание: х .__ixor__(у);
♦ х « у — сдвиг влево: х .__lshift __(у);
♦ у « х — сдвиг влево (экземпляр класса справа): х .__ r i s h i f t __(у);
♦ х « = у — сдвиг влево и присваивание: х .__i l s h i f t __(у);
♦ х » у — сдвиг вправо: х'.__rshift __(у);
♦ у » х — сдвиг вправо (экземпляр класса справа): х ._r r s h i f t___(у);
♦ х » = у — сдвиг вправо и присваивание: х . irshift __(у).
Перегрузка операторов сравнения производится с помощью следующих методов:
♦ х = у — равно: х .__eq__(у);
♦ х != у — не равно: х .__пе__(у);
♦ х < у — меньше: х .__i t __(у);
♦ х > у — больше: х .__g t__(у);
♦ х <= у — меньше или равно: х ._1е__ (у);
♦ х >= у — больше или равно: х .__де__ (у);
♦ у in х — проверка на вхождение: х .__contains__(у).
Пример перегрузки операторов сравнения приведен в листинге 13.14.


# In[ ]:


дз написать метод frac для сложения и умноженя дробей

